In a max/msp patcher, I have two kinds of objects: mvc.models and mvc.parameters. 
Each mvc.parameter can be bound to a parent mvc.model and each mvc.model can be bound to a parent mvc.model. This results in a tree-like graph, with a top-level model that has "mvc-root" as a parent. Theses mvc.models and mvc.parameters can be instanciated at any moment during patching.

I want to use a JS script that allows to manage the registration and unregistration these mvc.models and mvc.parameters.

Both these objects contains a dictionary, identified with a unique name (UID). This dictionary contains the following information about the module:
- the name of the module (a string))
- the parent model UID (a string)
- the type of module ("model" or "parameter")
- a list of child-models
- a list of child-parameters
- a list of pending-child-models (waiting to be initialized)
- a list of pending-child-parameters (waiting to be initialized)
- an URL style address, that is a concatenation of the module's name to the consecutive parent models, separated by a double colon, for instance "myModel::mySubModel::myParameter". This address is generated by the JS script, provided the parent models exist and are initialized.

When instanciating a mvc.model or a mvc.parameter, it automatically adds itself to the parent model's pending-child-models or pending-child-parameters, depending on its own type (this is done outside the javascript).

The mvc.models and mvc.parameters can calls the "register" function of the JS script when it is instanciated and "unregister" when deleted.

For a model or parameter to be registered, its parent model should be initialized. 

The script takes care of creating the corresponding namespaces, by maintaining two dictionaries:
- a dictionary that maps the organization of models
- a dictionary that maps the organization of parameters

If one create an mvc.model or mvc.parameter, whose parent model does not exist (or is not initialized), their UID will be added to the list of "pending child models" or "pending child parameters". This way, they will be automatically registered if the relevant parent mvc.model object is created at a later time in the patcher.

Can you write the javascript code that does that?


---
In the previous code, change the following thing:
- "name" should be "address" in the attribute dictionary
- "type" should be "mvc-type"
- when a child model is registered, it should be featured in the "childModels" of the parent node
- when a child model is unregistered, it should removed from the "childModels" of the parent node and added to the "pendingChildModels"
- when an mvc.model is unregistered, it should also be removed from the dictionary mvc.parameters


---

Your last code didn't match my expectation.

Here's the expected behaviour if ones delete a model:
- the "free" function is called
- it unregisters all of its childModels recursively
- it deletes its subtree in the model namespace and the parameter namespace
- the childModels and childParameters are moved to pendingModels and pendingParameters
- it cleans all attributes from the attr dictionary, except the childModels and childParameters

Here's the expected behaviour if ones delete a parameter:
- the "free" function is called
- it removes the parameter from the parameter namespace
- it removes itself from its parent's childParameter or pendingChildParameter
- it cleans all of its attribute dictionary

----

Three more things:
- when removing a model from the mvc.models dictionary, it should be completly remove (using MVC_MODELS.remove(fullAddress), not MVC_MODELS.remove(fullAddress + "::uid").
- when a model has pending child models and pending child parameters, the child parameters should be registered first.
- when a model is done registering (with all its pending models and parameters), it should send a message using the "messnamed" function, according to its uid, like: `messnamed (uid+".init", 1);`. Conversely, it should send a zero when it's done unregistering.

---

OK, I have now the following code and I would like to improve it by allowing addresses to be expressed as full-fledge brace-expansion notation. So this means the address of a model (or parameter) can be expressed like this :"myModel.{1..3}", which will expand to an array of 3 addresses [myModel.1, myModel.2, myModel.3]. Each of these addresses will then be attached as previously to the parent model.

```
/****************************************************************
 * MVC REGISTRATION MANAGER (UPDATED)
 * Max/MSP JavaScript
 *
 * Features:
 * - models & parameters with dynamic order
 * - tree structure with pending children
 * - full removal from namespace
 * - pending parameters initialized before models
 * - sends init message after registration/unregistration
 ****************************************************************/

var MVC_MODELS = new Dict("mvc.models");
var MVC_PARAMETERS = new Dict("mvc.parameters");

MVC_MODELS.quiet = 1;
MVC_PARAMETERS.quiet = 1;

/* ===================== UTILITIES ===================== */
function node(uid) {
    var d = new Dict(uid + ".attr");
    d.quiet = 1;
    return d;
}
function keys(d) { return d ? d.getkeys() : null; }
function invalid(v) { return v === null || v === undefined || v === "none"; }

/* ===================== REGISTER ===================== */
function register(uid) {
    var n = node(uid);
    var type = n.get("mvc-type");
    var localAddress = n.get("address");
    var parentUID = n.get("parent");

    if (invalid(type) || invalid(localAddress) || invalid(parentUID)) return;

    // Root model initializes immediately
    if (parentUID === "mvc.root") {
        initializeNode(n, null);
        return;
    }

    var parent = node(parentUID);

    /* --- Parent not initialized or not yet existing --- */
    if (invalid(parent.get("fullAddress"))) {

        if (type === "model") {
            parent.replace("pendingChildModels::" + uid, 1);
        } else {
            parent.replace("pendingChildParameters::" + uid, 1);
        }

        return;
    }

    /* --- Parent initialized --- */
    initializeNode(n, parent);
}


/* ===================== INITIALIZATION ===================== */
function initializeNode(n, parent) {
    var uid = n.get("uid");
    var type = n.get("mvc-type");
    var localAddress = n.get("address");

    //post("--initializeNode\n");
    var fullAddress = parent
        ? parent.get("fullAddress") + "::" + localAddress
        : localAddress;

    if (type === "model") {
        if (MVC_MODELS.contains(fullAddress)) return;
        MVC_MODELS.replace(fullAddress + "::uid", uid); // FULL removal
    } else {
        if (MVC_PARAMETERS.contains(fullAddress)) return;
        MVC_PARAMETERS.replace(fullAddress + "::uid", uid);
    }

    n.replace("fullAddress", fullAddress);
    n.replace("initialized", 1);

    if (parent) {
        if (type === "model") {
            parent.replace("childModels::" + uid, 1);
            parent.remove("pendingChildModels::" + uid);
        } else {
            parent.replace("childParameters::" + uid, 1);
            parent.remove("pendingChildParameters::" + uid);
        }
    }

    if (type === "model") {
        initializePendingChildren(n);
    }

    // Send init message after registration
    messnamed(uid + ".init", 1);
}

function initializePendingChildren(modelNode) {
    // --- First initialize pending parameters
    var pendingParams = keys(modelNode.get("pendingChildParameters"));
    if (pendingParams) {
        for (var j = 0; j < pendingParams.length; j++) {
            register(pendingParams[j]);
        }
    }

    // --- Then initialize pending models
    // so that parameters can preempt this
    var pendingModels = keys(modelNode.get("pendingChildModels"));
    if (pendingModels) {
        for (var i = 0; i < pendingModels.length; i++) {
            register(pendingModels[i]);
        }
    }
}

/* ===================== UNREGISTER ===================== */
function unregister(uid) {
    var n = node(uid);
    var type = n.get("mvc-type");

    if (type === "model") {
        unregisterModelSubtree(n);
    } else {
        unregisterParameter(n);
        messnamed(uid + ".init", 0);
    }
}

function unregisterModelSubtree(n) {
    var uid = n.get("uid");

    /* --- First unregister child models (deepest first) --- */
    var childModels = keys(n.get("childModels"));
    if (childModels) {
        for (var i = 0; i < childModels.length; i++) {
            unregisterModelSubtree(node(childModels[i]));
        }
    }

    /* --- Then unregister child parameters --- */
    var childParams = keys(n.get("childParameters"));
    if (childParams) {
        for (var j = 0; j < childParams.length; j++) {
            unregisterParameter(node(childParams[j]));
            messnamed(childParams[j] + ".init", 0);
        }
    }

    /* --- Finally unregister THIS model --- */
    unregisterModel(n);

    /* --- Emit init 0 AFTER children --- */
    messnamed(uid + ".init", 0);
}

function unregisterModel(n) {
    var uid = n.get("uid");
    var fullAddress = n.get("fullAddress");
    var parentUID = n.get("parent");

    if (!invalid(fullAddress)) {
        MVC_MODELS.remove(fullAddress);
        removeParametersByPrefix(fullAddress);
    }

    moveChildrenToPending(n, "childModels", "pendingChildModels");
    moveChildrenToPending(n, "childParameters", "pendingChildParameters");

    if (!invalid(parentUID) && parentUID !== "mvc.root") {
        var parent = node(parentUID);
        parent.remove("childModels::" + uid);
        parent.replace("pendingChildModels::" + uid, 1);
    }

    n.remove("fullAddress");
    n.remove("initialized");
}


function unregisterParameter(n) {
    var uid = n.get("uid");
    var fullAddress = n.get("fullAddress");
    var parentUID = n.get("parent");

    if (!invalid(fullAddress)) {
        MVC_PARAMETERS.remove(fullAddress);
    }

    if (!invalid(parentUID) && parentUID !== "mvc.root") {
        var parent = node(parentUID);
        parent.remove("childParameters::" + uid);
        parent.replace("pendingChildParameters::" + uid, 1);
    }

    n.remove("fullAddress");
    n.remove("initialized");
}

/* ===================== HELPERS ===================== */
function moveChildrenToPending(n, childKey, pendingKey) {
    var children = keys(n.get(childKey));
    if (!children) return;

    for (var i = 0; i < children.length; i++) {
        n.replace(pendingKey + "::" + children[i], 1);
        n.remove(childKey + "::" + children[i]);
    }
}

function removeParametersByPrefix(prefix) {
    var all = keys(MVC_PARAMETERS);
    if (!all) return;

    for (var i = 0; i < all.length; i++) {
        if (all[i].indexOf(prefix + "::") === 0) {
            MVC_PARAMETERS.remove(all[i]);
        }
    }
}

/* ===================== FREE ===================== */
function free(uid) {
    var n = node(uid);
    var type = n.get("mvc-type");

    if (type === "model") {
        freeModel(n);
    } else {
        freeParameter(n);
    }

    messnamed(uid + ".init", 0);
}


function freeModel(n) {
    var uid = n.get("uid");
    var fullAddress = n.get("fullAddress");
    var parentUID = n.get("parent");

    /* 1. Unregister child models recursively */
    var childModels = keys(n.get("childModels"));
    if (childModels) {
        for (var i = 0; i < childModels.length; i++) {
            unregisterModelSubtree(node(childModels[i]));
        }
    }

    /* 2. Delete subtree from namespaces */
    if (!invalid(fullAddress)) {
        MVC_MODELS.remove(fullAddress);
        MVC_PARAMETERS.remove(fullAddress);
        //removeParametersByPrefix(fullAddress);
    }

    /* 3. Move children to pending */
    moveChildrenToPending(n, "childModels", "pendingChildModels");
    moveChildrenToPending(n, "childParameters", "pendingChildParameters");

    /* 4. remove self from parent's (pending) children */
    if (!invalid(parentUID)) {
        var parent = node(parentUID);
        parent.remove("childModels::" + uid);
        parent.remove("pendingChildModels::" + uid);

    }


    // 5. Clean attribute node, but keep pending children
    n.remove("childModels");
    n.remove("childParameters");
    //n.remove("pendingChildModels");
    //n.remove("pendingChildParameters");
    n.remove("fullAddress");
    n.remove("initialized");
    n.remove("address");
    n.remove("uid");
    n.remove("parent");
    n.remove("mvc-type");
}


function freeParameter(n) {
    var uid = n.get("uid");
    var fullAddress = n.get("fullAddress");
    var parentUID = n.get("parent");

    if (!invalid(fullAddress)) {
        MVC_PARAMETERS.remove(fullAddress);
    }

    if (!invalid(parentUID)) {
        var parent = node(parentUID);
        parent.remove("childParameters::" + uid);
        parent.remove("pendingChildParameters::" + uid);

    }

    n.clear();
}



/* ===================== DEBUG ===================== */
function dump() {
    post("---- MVC MODELS ----\n");
    post(MVC_MODELS.stringify(), "\n");
    post("---- MVC PARAMETERS ----\n");
    post(MVC_PARAMETERS.stringify(), "\n");
}
```